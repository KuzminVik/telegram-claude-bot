#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import json
import logging
import asyncio
from pathlib import Path
from datetime import datetime, timedelta
import random
import re

from telegram import Update, Bot
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

from anthropic import Anthropic
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
TELEGRAM_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
ANTHROPIC_API_KEY = os.getenv('ANTHROPIC_API_KEY')

if not TELEGRAM_TOKEN or not ANTHROPIC_API_KEY:
    raise ValueError("TELEGRAM_BOT_TOKEN –∏ ANTHROPIC_API_KEY –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Anthropic
anthropic_client = Anthropic(api_key=ANTHROPIC_API_KEY)

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏
CONVERSATIONS_DIR = Path("/root/telegram-bot/conversations")
MAX_HISTORY_LENGTH = 30
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 –ú–ë
COMPRESSION_THRESHOLD = 10

# –ü—É—Ç–∏ –∫ —Ñ–∞–π–ª–∞–º –ø–æ–≥–æ–¥—ã
WEATHER_SUBS_FILE = Path("/root/telegram-bot/weather_subscriptions.json")
WEATHER_HISTORY_FILE = Path("/root/telegram-bot/weather_history.json")

# –ü—É—Ç–∏ –∫ MCP —Å–µ—Ä–≤–µ—Ä–∞–º
MCP_WEATHER_SERVER_PATH = "/home/claude/mcp-weather-server/server.js"
MCP_NEWS_SERVER_PATH = "/home/claude/mcp-news-server/server.js"

# SSH –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è mobile-mcp
MCP_MOBILE_SSH_HOST = "localhost"
MCP_MOBILE_SSH_PORT = 2222
MCP_MOBILE_SSH_USER = "vkuzmin"
MCP_MOBILE_SSH_KEY = "/root/.ssh/server_to_mac"
MCP_MOBILE_NODE_PATH = "/Users/vkuzmin/.nvm/versions/node/v20.19.6/bin/node"
MCP_MOBILE_SERVER_PATH = "/Users/vkuzmin/mcp-servers/mobile-mcp/lib/index.js"
MCP_MOBILE_START_EMULATOR_SCRIPT = "/Users/vkuzmin/start-emulator.sh"

# SSH –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è ollama-mcp (RAG)
MCP_OLLAMA_SSH_HOST = "localhost"
MCP_OLLAMA_SSH_PORT = 2222
MCP_OLLAMA_SSH_USER = "vkuzmin"
MCP_OLLAMA_SSH_KEY = "/root/.ssh/server_to_mac"
MCP_OLLAMA_NODE_PATH = "/Users/vkuzmin/.nvm/versions/node/v20.19.6/bin/node"
MCP_OLLAMA_SERVER_PATH = "/Users/vkuzmin/mcp-servers/ollama-mcp/server.js"

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
mcp_weather_client = None
mcp_news_client = None
mcp_mobile_client = None
mcp_ollama_client = None
scheduler = None
bot_instance = None  # –î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –±–æ—Ç—É –∏–∑ scheduled –∑–∞–¥–∞—á

# –°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è —Å–∂–∞—Ç–∏—è –∏—Å—Ç–æ—Ä–∏–∏
COMPRESSION_SYSTEM_PROMPT = """You are a helpful assistant that creates concise summaries of conversation history.
Your task is to create a brief summary of the conversation provided. The summary should:
1. Capture the key topics discussed
2. Preserve important facts, decisions, or conclusions
3. Be concise but informative (2-4 sentences)
4. Be written in the same language as the conversation

Respond with ONLY a valid JSON object in this format:
{"summary": "your summary text here"}

Do not include any markdown formatting, code blocks, or additional text."""

# =============================================================================
# MCP Weather Client
# =============================================================================

class MCPWeatherClient:
    """–ö–ª–∏–µ–Ω—Ç –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å MCP Weather Server"""
    
    def __init__(self, server_path: str):
        self.server_path = server_path
        self.process = None
        self.lock = asyncio.Lock()  # –î–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤
        
    async def start(self):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å MCP —Å–µ—Ä–≤–µ—Ä"""
        try:
            self.process = await asyncio.create_subprocess_exec(
                'node', self.server_path,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            # –ß–∏—Ç–∞–µ–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–æ–∫—É –∏–∑ stderr (–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ —Å–µ—Ä–≤–µ—Ä–∞)
            if self.process.stderr:
                greeting = await self.process.stderr.readline()
                logger.info(f"MCP Server: {greeting.decode().strip()}")
            
            logger.info("‚úì MCP Weather Server started")
            return True
        except Exception as e:
            logger.error(f"Failed to start MCP Weather Server: {e}")
            return False
    
    async def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å MCP —Å–µ—Ä–≤–µ—Ä"""
        if self.process:
            try:
                self.process.terminate()
                await asyncio.wait_for(self.process.wait(), timeout=5.0)
            except asyncio.TimeoutError:
                self.process.kill()
                await self.process.wait()
            logger.info("‚úì MCP Weather Server stopped")
    
    async def call_tool(self, tool_name: str, arguments: dict) -> dict:
        """–í—ã–∑–≤–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç MCP —Å–µ—Ä–≤–µ—Ä–∞"""
        if not self.process:
            logger.error("MCP Weather Server is not running")
            return None
        
        async with self.lock:  # –¢–æ–ª—å–∫–æ –æ–¥–∏–Ω –∑–∞–ø—Ä–æ—Å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
            try:
                request = {
                    "jsonrpc": "2.0",
                    "method": "tools/call",
                    "params": {
                        "name": tool_name,
                        "arguments": arguments
                    },
                    "id": 1
                }
                
                request_json = json.dumps(request) + '\n'
                logger.info(f"Sending to MCP: {request_json.strip()}")
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
                self.process.stdin.write(request_json.encode())
                await self.process.stdin.drain()
                
                # –ß–∏—Ç–∞–µ–º –æ—Ç–≤–µ—Ç (—Å —Ç–∞–π–º–∞—É—Ç–æ–º)
                response_line = await asyncio.wait_for(
                    self.process.stdout.readline(),
                    timeout=10.0
                )
                
                response_text = response_line.decode().strip()
                logger.info(f"Received from MCP: {response_text[:200]}...")
                
                response = json.loads(response_text)
                
                if 'result' in response:
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ result.content[0].text
                    content = response['result']['content'][0]['text']
                    return json.loads(content)
                elif 'error' in response:
                    logger.error(f"MCP tool call error: {response['error']}")
                    return None
                else:
                    logger.error(f"Unexpected MCP response format: {response}")
                    return None
                    
            except asyncio.TimeoutError:
                logger.error("MCP tool call timeout")
                return None
            except Exception as e:
                logger.error(f"Error calling MCP tool: {e}")
                return None

# =============================================================================
# MCP News Client
# =============================================================================

class MCPNewsClient:
    """–ö–ª–∏–µ–Ω—Ç –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å MCP News Server"""
    
    def __init__(self, server_path: str):
        self.server_path = server_path
        self.process = None
        self.lock = asyncio.Lock()  # –î–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤
        
    async def start(self):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å MCP —Å–µ—Ä–≤–µ—Ä"""
        try:
            self.process = await asyncio.create_subprocess_exec(
                'node', self.server_path,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            # –ß–∏—Ç–∞–µ–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–æ–∫—É –∏–∑ stderr (–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ —Å–µ—Ä–≤–µ—Ä–∞)
            if self.process.stderr:
                greeting = await self.process.stderr.readline()
                logger.info(f"MCP News Server: {greeting.decode().strip()}")
            
            logger.info("‚úì MCP News Server started")
            return True
        except Exception as e:
            logger.error(f"Failed to start MCP News Server: {e}")
            return False
    
    async def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å MCP —Å–µ—Ä–≤–µ—Ä"""
        if self.process:
            try:
                self.process.terminate()
                await asyncio.wait_for(self.process.wait(), timeout=5.0)
            except asyncio.TimeoutError:
                self.process.kill()
                await self.process.wait()
            logger.info("‚úì MCP News Server stopped")
    
    async def call_tool(self, tool_name: str, arguments: dict) -> dict:
        """–í—ã–∑–≤–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç MCP —Å–µ—Ä–≤–µ—Ä–∞"""
        if not self.process:
            logger.error("MCP News Server is not running")
            return None
        
        async with self.lock:  # –¢–æ–ª—å–∫–æ –æ–¥–∏–Ω –∑–∞–ø—Ä–æ—Å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
            try:
                request = {
                    "jsonrpc": "2.0",
                    "method": "tools/call",
                    "params": {
                        "name": tool_name,
                        "arguments": arguments
                    },
                    "id": 1
                }
                
                request_json = json.dumps(request) + '\n'
                logger.info(f"Sending to MCP News: {request_json.strip()}")
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
                self.process.stdin.write(request_json.encode())
                await self.process.stdin.drain()
                
                # –ß–∏—Ç–∞–µ–º –æ—Ç–≤–µ—Ç (—Å —Ç–∞–π–º–∞—É—Ç–æ–º)
                response_line = await asyncio.wait_for(
                    self.process.stdout.readline(),
                    timeout=10.0
                )
                
                response_text = response_line.decode().strip()
                logger.info(f"Received from MCP News: {response_text[:200]}...")
                
                response = json.loads(response_text)
                
                if 'result' in response:
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ result.content[0].text
                    content = response['result']['content'][0]['text']
                    return json.loads(content)
                elif 'error' in response:
                    logger.error(f"MCP News tool call error: {response['error']}")
                    return None
                else:
                    logger.error(f"Unexpected MCP News response format: {response}")
                    return None
                    
            except asyncio.TimeoutError:
                logger.error("MCP News tool call timeout")
                return None
            except Exception as e:
                logger.error(f"Error calling MCP News tool: {e}")
                return None

# =============================================================================
# MCP Mobile Client (—á–µ—Ä–µ–∑ SSH)
# =============================================================================

class MCPMobileClient:
    """–ö–ª–∏–µ–Ω—Ç –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å MCP Mobile Server —á–µ—Ä–µ–∑ SSH"""
    
    def __init__(self, ssh_host: str, ssh_port: int, ssh_user: str, ssh_key: str, server_path: str):
        self.ssh_host = ssh_host
        self.ssh_port = ssh_port
        self.ssh_user = ssh_user
        self.ssh_key = ssh_key
        self.server_path = server_path
        self.process = None
        self.lock = asyncio.Lock()
        
    async def start(self):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å MCP —Å–µ—Ä–≤–µ—Ä —á–µ—Ä–µ–∑ SSH"""
        try:
            # SSH –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ mobile-mcp –Ω–∞ Mac
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º ANDROID_HOME –∏ PATH –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º node
            ssh_command = [
                'ssh',
                '-i', self.ssh_key,
                '-p', str(self.ssh_port),
                '-o', 'StrictHostKeyChecking=no',
                '-o', 'UserKnownHostsFile=/dev/null',
                f'{self.ssh_user}@{self.ssh_host}',
                f'export ANDROID_HOME=/Users/vkuzmin/Library/android/sdk && export PATH=$ANDROID_HOME/platform-tools:$ANDROID_HOME/emulator:$PATH && /Users/vkuzmin/.nvm/versions/node/v20.19.6/bin/node {self.server_path}'
            ]
            
            self.process = await asyncio.create_subprocess_exec(
                *ssh_command,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            # –ß–∏—Ç–∞–µ–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–æ–∫—É –∏–∑ stdout (–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ MCP —Å–µ—Ä–≤–µ—Ä–∞)
            try:
                greeting = await asyncio.wait_for(
                    self.process.stdout.readline(),
                    timeout=5.0
                )
                logger.info(f"MCP Mobile Server: {greeting.decode().strip()}")
            except asyncio.TimeoutError:
                logger.warning("No greeting from MCP Mobile Server")
            
            logger.info("‚úì MCP Mobile Server started (via SSH)")
            return True
        except Exception as e:
            logger.error(f"Failed to start MCP Mobile Server: {e}")
            return False
    
    async def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å MCP —Å–µ—Ä–≤–µ—Ä"""
        if self.process:
            try:
                self.process.terminate()
                await asyncio.wait_for(self.process.wait(), timeout=5.0)
            except asyncio.TimeoutError:
                self.process.kill()
                await self.process.wait()
            logger.info("‚úì MCP Mobile Server stopped")
    
    async def call_tool(self, tool_name: str, arguments: dict) -> dict:
        """–í—ã–∑–≤–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç MCP —Å–µ—Ä–≤–µ—Ä–∞"""
        if not self.process:
            logger.error("MCP Mobile Server is not running")
            return None
        
        async with self.lock:
            try:
                request = {
                    "jsonrpc": "2.0",
                    "method": "tools/call",
                    "params": {
                        "name": tool_name,
                        "arguments": arguments
                    },
                    "id": 1
                }
                
                request_json = json.dumps(request) + '\n'
                logger.info(f"Sending to MCP Mobile: {request_json.strip()}")
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
                self.process.stdin.write(request_json.encode())
                await self.process.stdin.drain()
                
                # –ß–∏—Ç–∞–µ–º –æ—Ç–≤–µ—Ç (—Å —Ç–∞–π–º–∞—É—Ç–æ–º)
                response_line = await asyncio.wait_for(
                    self.process.stdout.readline(),
                    timeout=15.0  # –ë–æ–ª—å—à–µ timeout –¥–ª—è mobile –æ–ø–µ—Ä–∞—Ü–∏–π
                )
                
                response_text = response_line.decode().strip()
                logger.info(f"Received from MCP Mobile: {response_text[:200]}...")
                
                response = json.loads(response_text)
                
                if 'result' in response:
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ result.content[0].text
                    content = response['result']['content'][0]['text']
                    return json.loads(content)
                elif 'error' in response:
                    logger.error(f"MCP Mobile tool call error: {response['error']}")
                    return None
                else:
                    logger.error(f"Unexpected MCP Mobile response format: {response}")
                    return None
                    
            except asyncio.TimeoutError:
                logger.error("MCP Mobile tool call timeout")
                return None
            except Exception as e:
                logger.error(f"Error calling MCP Mobile tool: {e}")
                return None

# =============================================================================

# =============================================================================
# MCP Ollama Client (RAG)
# =============================================================================

class MCPOllamaClient:
    """–ö–ª–∏–µ–Ω—Ç –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å MCP Ollama Server (RAG)"""
    
    def __init__(self, ssh_host: str, ssh_port: int, ssh_user: str, 
                 ssh_key: str, node_path: str, server_path: str):
        self.ssh_host = ssh_host
        self.ssh_port = ssh_port
        self.ssh_user = ssh_user
        self.ssh_key = ssh_key
        self.node_path = node_path
        self.server_path = server_path
        self.process = None
        self.lock = asyncio.Lock()
        
    async def start(self):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å MCP —Å–µ—Ä–≤–µ—Ä —á–µ—Ä–µ–∑ SSH"""
        try:
            ssh_command = [
                'ssh',
                '-i', self.ssh_key,
                '-p', str(self.ssh_port),
                '-o', 'StrictHostKeyChecking=no',
                '-o', 'UserKnownHostsFile=/dev/null',
                f'{self.ssh_user}@{self.ssh_host}',
                f'{self.node_path} {self.server_path}'
            ]
            
            self.process = await asyncio.create_subprocess_exec(
                *ssh_command,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                greeting = await asyncio.wait_for(
                    self.process.stderr.readline(),
                    timeout=5.0
                )
                logger.info(f"MCP Ollama: {greeting.decode().strip()}")
            except asyncio.TimeoutError:
                logger.warning("No greeting from MCP Ollama")
            
            logger.info("‚úì MCP Ollama Server started")
            return True
        except Exception as e:
            logger.error(f"Failed to start MCP Ollama: {e}")
            return False
    
    async def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å MCP —Å–µ—Ä–≤–µ—Ä"""
        if self.process:
            try:
                self.process.terminate()
                await asyncio.wait_for(self.process.wait(), timeout=5.0)
            except asyncio.TimeoutError:
                self.process.kill()
                await self.process.wait()
            logger.info("‚úì MCP Ollama stopped")
    
    async def call_tool(self, tool_name: str, arguments: dict) -> dict:
        """–í—ã–∑–≤–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç MCP —Å–µ—Ä–≤–µ—Ä–∞"""
        if not self.process:
            logger.error("MCP Ollama not running")
            return None
        
        async with self.lock:
            try:
                request = {
                    "jsonrpc": "2.0",
                    "method": "tools/call",
                    "params": {"name": tool_name, "arguments": arguments},
                    "id": 1
                }
                
                request_json = json.dumps(request) + '\n'
                self.process.stdin.write(request_json.encode())
                await self.process.stdin.drain()
                
                response_line = await asyncio.wait_for(
                    self.process.stdout.readline(),
                    timeout=30.0
                )
                
                response = json.loads(response_line.decode().strip())
                
                if 'result' in response:
                    content = response['result']['content'][0]['text']
                    return json.loads(content)
                elif 'error' in response:
                    logger.error(f"MCP Ollama error: {response['error']}")
                    return None
                    
            except Exception as e:
                logger.error(f"Error calling MCP Ollama: {e}")
                return None

# –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–æ–≤
# =============================================================================

def ensure_conversations_dir():
    """–°–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–π –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç"""
    CONVERSATIONS_DIR.mkdir(parents=True, exist_ok=True)
    logger.info(f"Conversations directory ensured: {CONVERSATIONS_DIR}")

def get_conversation_filepath(user_id: int) -> Path:
    """–ü–æ–ª—É—á–∏—Ç—å –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    return CONVERSATIONS_DIR / f"user_{user_id}.json"

def load_conversation(user_id: int) -> list:
    """
    –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏–∑ —Ñ–∞–π–ª–∞
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –∏–ª–∏ –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    """
    filepath = get_conversation_filepath(user_id)
    
    if not filepath.exists():
        logger.info(f"No conversation file for user {user_id}")
        return []
    
    try:
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞
        file_size = filepath.stat().st_size
        if file_size > MAX_FILE_SIZE:
            logger.warning(f"Conversation file too large for user {user_id}: {file_size} bytes")
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏ –æ–±—Ä–µ–∑–∞–µ–º –¥–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö MAX_HISTORY_LENGTH —Å–æ–æ–±—â–µ–Ω–∏–π
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
                messages = data.get('messages', [])
                if len(messages) > MAX_HISTORY_LENGTH:
                    messages = messages[-MAX_HISTORY_LENGTH:]
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±—Ä–µ–∑–∞–Ω–Ω—É—é –≤–µ—Ä—Å–∏—é
                    save_conversation(user_id, messages)
                return messages
        
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
            messages = data.get('messages', [])
            logger.info(f"Loaded {len(messages)} messages for user {user_id}")
            return messages
            
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in conversation file for user {user_id}: {e}")
        # –°–æ–∑–¥–∞—ë–º backup –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
        backup_path = filepath.with_suffix('.json.backup')
        filepath.rename(backup_path)
        logger.info(f"Created backup: {backup_path}")
        return []
    except Exception as e:
        logger.error(f"Error loading conversation for user {user_id}: {e}")
        return []

def save_conversation(user_id: int, messages: list) -> bool:
    """
    –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –≤ —Ñ–∞–π–ª
    –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–æ MAX_HISTORY_LENGTH
    """
    filepath = get_conversation_filepath(user_id)
    
    try:
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π
        if len(messages) > MAX_HISTORY_LENGTH:
            messages = messages[-MAX_HISTORY_LENGTH:]
        
        data = {
            "user_id": user_id,
            "last_updated": datetime.now().isoformat(),
            "message_count": len(messages),
            "messages": messages
        }
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        
        file_size = filepath.stat().st_size
        logger.info(f"Saved {len(messages)} messages for user {user_id} ({file_size} bytes)")
        return True
        
    except Exception as e:
        logger.error(f"Error saving conversation for user {user_id}: {e}")
        return False

def delete_conversation(user_id: int) -> bool:
    """–£–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª –∏—Å—Ç–æ—Ä–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    filepath = get_conversation_filepath(user_id)
    
    try:
        if filepath.exists():
            filepath.unlink()
            logger.info(f"Deleted conversation file for user {user_id}")
            return True
        return False
    except Exception as e:
        logger.error(f"Error deleting conversation for user {user_id}: {e}")
        return False

def get_conversation_stats(user_id: int) -> dict:
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —Ñ–∞–π–ª—É –∏—Å—Ç–æ—Ä–∏–∏"""
    filepath = get_conversation_filepath(user_id)
    
    if not filepath.exists():
        return {
            "exists": False,
            "message_count": 0,
            "file_size": 0,
            "file_size_mb": 0
        }
    
    try:
        file_size = filepath.stat().st_size
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
            message_count = data.get('message_count', 0)
        
        return {
            "exists": True,
            "message_count": message_count,
            "file_size": file_size,
            "file_size_mb": round(file_size / (1024 * 1024), 2)
        }
    except Exception as e:
        logger.error(f"Error getting stats for user {user_id}: {e}")
        return {
            "exists": True,
            "message_count": 0,
            "file_size": 0,
            "file_size_mb": 0
        }

# =============================================================================
# –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø–æ–¥–ø–∏—Å–∫–∞–º–∏ –Ω–∞ –ø–æ–≥–æ–¥—É
# =============================================================================

def load_weather_subscriptions() -> dict:
    """–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –ø–æ–≥–æ–¥—É"""
    try:
        if WEATHER_SUBS_FILE.exists():
            with open(WEATHER_SUBS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
    except Exception as e:
        logger.error(f"Error loading weather subscriptions: {e}")
        return {}

def save_weather_subscriptions(subs: dict) -> bool:
    """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –ø–æ–≥–æ–¥—É"""
    try:
        with open(WEATHER_SUBS_FILE, 'w', encoding='utf-8') as f:
            json.dump(subs, f, ensure_ascii=False, indent=2)
        logger.info(f"Saved {len(subs)} weather subscription(s)")
        return True
    except Exception as e:
        logger.error(f"Error saving weather subscriptions: {e}")
        return False

def load_weather_history() -> dict:
    """–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –ø–æ–≥–æ–¥—ã (—Ç–æ–ª—å–∫–æ –≤—á–µ—Ä–∞—à–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ)"""
    try:
        if WEATHER_HISTORY_FILE.exists():
            with open(WEATHER_HISTORY_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
    except Exception as e:
        logger.error(f"Error loading weather history: {e}")
        return {}

def save_weather_history(history: dict) -> bool:
    """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –ø–æ–≥–æ–¥—ã"""
    try:
        with open(WEATHER_HISTORY_FILE, 'w', encoding='utf-8') as f:
            json.dump(history, f, ensure_ascii=False, indent=2)
        logger.info(f"Saved weather history for {len(history)} user(s)")
        return True
    except Exception as e:
        logger.error(f"Error saving weather history: {e}")
        return False

def simulate_yesterday_weather(current_weather: dict) -> dict:
    """
    –°–æ–∑–¥–∞—Ç—å —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –≤—á–µ—Ä–∞—à–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–µ–π –ø–æ–≥–æ–¥—ã
    –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É ¬±2-4¬∞C
    """
    try:
        # –ü–∞—Ä—Å–∏–º —Ç–µ–∫—É—â—É—é –ø–æ–≥–æ–¥—É –∏–∑ —Å—Ç—Ä–æ–∫–∏
        lines = current_weather.get('weather_info', '').split('\n')
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É (–ø—Ä–∏–º–µ—Ä–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥)
        temp = None
        feels_like = None
        condition = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        humidity = 70
        wind_speed = 10
        
        for line in lines:
            if '–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞:' in line:
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —á–∏—Å–ª–æ –∏–∑ —Å—Ç—Ä–æ–∫–∏ —Ç–∏–ø–∞ "üå°Ô∏è –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: -5¬∞C"
                match = re.search(r'(-?\d+\.?\d*)¬∞C', line)
                if match:
                    temp = float(match.group(1))
            elif '–æ—â—É—â–∞–µ—Ç—Å—è –∫–∞–∫' in line:
                match = re.search(r'(-?\d+\.?\d*)¬∞C', line)
                if match:
                    feels_like = float(match.group(1))
            elif '–°–æ—Å—Ç–æ—è–Ω–∏–µ:' in line or '–£—Å–ª–æ–≤–∏—è:' in line:
                condition = line.split(':')[1].strip()
            elif '–í–ª–∞–∂–Ω–æ—Å—Ç—å:' in line:
                match = re.search(r'(\d+)%', line)
                if match:
                    humidity = int(match.group(1))
            elif '–í–µ—Ç–µ—Ä:' in line:
                match = re.search(r'(\d+)', line)
                if match:
                    wind_speed = int(match.group(1))
        
        # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å, –±–µ—Ä—ë–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        if temp is None:
            temp = random.randint(-10, 5)
        if feels_like is None:
            feels_like = temp - 3
        
        # –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –¥–ª—è "–≤—á–µ—Ä–∞"
        temp_delta = random.randint(2, 4) * random.choice([-1, 1])
        yesterday_temp = temp + temp_delta
        yesterday_feels = feels_like + temp_delta
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ–≥–Ω–æ–∑ –µ—Å–ª–∏ –µ—Å—Ç—å, –∏–Ω–∞—á–µ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º
        if 'forecast' in current_weather:
            forecast = current_weather['forecast']
            temp_max = forecast.get('temp_max', yesterday_temp + random.randint(3, 5))
            temp_min = forecast.get('temp_min', yesterday_temp - random.randint(3, 5))
            precipitation = forecast.get('precipitation_probability', random.randint(10, 30))
        else:
            temp_max = yesterday_temp + random.randint(3, 5)
            temp_min = yesterday_temp - random.randint(3, 5)
            precipitation = random.randint(10, 30)
        
        yesterday_data = {
            "date": (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d"),
            "city": current_weather.get('city', 'Unknown'),
            "current": {
                "temp": round(yesterday_temp, 1),
                "feels_like": round(yesterday_feels, 1),
                "condition": condition,
                "humidity": max(0, min(100, humidity + random.randint(-10, 10))),
                "wind_speed": max(0, wind_speed + random.randint(-3, 3))
            },
            "forecast": {
                "temp_max": round(temp_max, 1),
                "temp_min": round(temp_min, 1),
                "precipitation_probability": max(0, min(100, precipitation + random.randint(-10, 10)))
            }
        }
        
        logger.info(f"Simulated yesterday weather: {yesterday_data}")
        return yesterday_data
        
    except Exception as e:
        logger.error(f"Error simulating yesterday weather: {e}")
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        return {
            "date": (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d"),
            "city": current_weather.get('city', 'Unknown'),
            "current": {
                "temp": random.randint(-10, 5),
                "feels_like": random.randint(-15, 0),
                "condition": "–û–±–ª–∞—á–Ω–æ",
                "humidity": 70,
                "wind_speed": 10
            },
            "forecast": {
                "temp_max": random.randint(0, 5),
                "temp_min": random.randint(-15, -5),
                "precipitation_probability": 30
            }
        }

# =============================================================================
# –§—É–Ω–∫—Ü–∏–∏ —É—Ç—Ä–µ–Ω–Ω–µ–π —Ä–∞—Å—Å—ã–ª–∫–∏ –ø–æ–≥–æ–¥—ã
# =============================================================================

async def generate_comparison_summary(yesterday_data: dict, today_data: dict, city: str) -> str:
    """
    –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∞–º–º–∞—Ä–∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –ø–æ–≥–æ–¥—ã —á–µ—Ä–µ–∑ Claude
    """
    try:
        comparison_prompt = f"""–°—Ä–∞–≤–Ω–∏ –ø–æ–≥–æ–¥—É –≤ –≥–æ—Ä–æ–¥–µ {city} –º–µ–∂–¥—É –≤—á–µ—Ä–∞ –∏ —Å–µ–≥–æ–¥–Ω—è.

–í–ß–ï–†–ê ({yesterday_data['date']}):
- –¢–µ–∫—É—â–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: {yesterday_data['current']['temp']}¬∞C
- –ü—Ä–æ–≥–Ω–æ–∑: –º–∞–∫—Å {yesterday_data['forecast']['temp_max']}¬∞C, –º–∏–Ω {yesterday_data['forecast']['temp_min']}¬∞C
- –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –æ—Å–∞–¥–∫–æ–≤: {yesterday_data['forecast']['precipitation_probability']}%

–°–ï–ì–û–î–ù–Ø:
- –¢–µ–∫—É—â–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: {today_data['current']['temp']}¬∞C
- –ü—Ä–æ–≥–Ω–æ–∑: –º–∞–∫—Å {today_data['forecast']['temp_max']}¬∞C, –º–∏–Ω {today_data['forecast']['temp_min']}¬∞C
- –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –æ—Å–∞–¥–∫–æ–≤: {today_data['forecast']['precipitation_probability']}%

–°–æ–∑–¥–∞–π –ö–†–ê–¢–ö–û–ï (2-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è) —Å–∞–º–º–∞—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ. –£–∫–∞–∂–∏:
1. –ö–∞–∫ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å —Ç–µ–∫—É—â–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞
2. –ö–∞–∫ –∏–∑–º–µ–Ω–∏–ª—Å—è –ø—Ä–æ–≥–Ω–æ–∑ (—Ç–µ–ø–ª–µ–µ/—Ö–æ–ª–æ–¥–Ω–µ–µ, –±–æ–ª—å—à–µ/–º–µ–Ω—å—à–µ –æ—Å–∞–¥–∫–æ–≤)

–û—Ç–≤–µ—Ç—å –¢–û–õ–¨–ö–û —Å–∞–º–º–∞—Ä–∏, –±–µ–∑ –ª–∏—à–Ω–µ–≥–æ —Ç–µ–∫—Å—Ç–∞."""

        response = anthropic_client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=300,
            messages=[
                {"role": "user", "content": comparison_prompt}
            ]
        )
        
        summary = response.content[0].text.strip()
        logger.info(f"Generated comparison summary: {summary}")
        return summary
        
    except Exception as e:
        logger.error(f"Error generating comparison summary: {e}")
        # Fallback - –ø—Ä–æ—Å—Ç–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
        temp_diff = round(today_data['current']['temp'] - yesterday_data['current']['temp'], 1)
        if temp_diff > 0:
            return f"–ü–æ—Ç–µ–ø–ª–µ–ª–æ –Ω–∞ {temp_diff}¬∞C –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å–æ –≤—á–µ—Ä–∞."
        elif temp_diff < 0:
            return f"–ü–æ—Ö–æ–ª–æ–¥–∞–ª–æ –Ω–∞ {abs(temp_diff)}¬∞C –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å–æ –≤—á–µ—Ä–∞."
        else:
            return "–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –ø—Ä–∏–º–µ—Ä–Ω–æ —Ç–∞–∫–∞—è –∂–µ –∫–∞–∫ –≤—á–µ—Ä–∞."

async def send_morning_weather():
    """
    –£—Ç—Ä–µ–Ω–Ω—è—è —Ä–∞—Å—Å—ã–ª–∫–∞ –ø–æ–≥–æ–¥—ã + –Ω–æ–≤–æ—Å—Ç–µ–π –≤—Å–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º
    –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é
    """
    logger.info("üåÖ Starting morning weather + news broadcast")
    
    if not bot_instance or not mcp_weather_client:
        logger.error("Bot or MCP client not initialized")
        return
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ–¥–ø–∏—Å–∫–∏
    subs = load_weather_subscriptions()
    if not subs:
        logger.info("No weather subscriptions")
        return
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é
    history = load_weather_history()
    
    # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤–æ—Å—Ç–∏ –æ–¥–∏–Ω —Ä–∞–∑ –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    news_result = None
    if mcp_news_client:
        logger.info("Fetching morning news...")
        news_result = await mcp_news_client.call_tool(
            "get_news",
            {"category": "–æ–±—â–∏–µ", "limit": 3}
        )
        if news_result:
            logger.info("‚úì News fetched successfully")
        else:
            logger.warning("Failed to fetch news")
    
    for user_id_str, sub_data in subs.items():
        try:
            user_id = int(user_id_str)
            city = sub_data['city']
            
            logger.info(f"Sending morning broadcast to user {user_id} for {city}")
            
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –ø–æ–≥–æ–¥—É + –ø—Ä–æ–≥–Ω–æ–∑ —á–µ—Ä–µ–∑ MCP
            result = await mcp_weather_client.call_tool(
                "get_weather",
                {"city": city, "include_forecast": True}
            )
            
            if not result or 'weather_info' not in result:
                logger.error(f"Failed to get weather for {city}")
                await bot_instance.send_message(
                    chat_id=user_id,
                    text=f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–æ–≥–æ–¥—É –¥–ª—è –≥–æ—Ä–æ–¥–∞ {city}"
                )
                continue
            
            # –ü–∞—Ä—Å–∏–º —Ç–µ–∫—É—â—É—é –ø–æ–≥–æ–¥—É
            weather_lines = result['weather_info'].split('\n')
            current_temp = None
            for line in weather_lines:
                if '–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞:' in line:
                    match = re.search(r'(-?\d+\.?\d*)¬∞C', line)
                    if match:
                        current_temp = float(match.group(1))
                        break
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–≥–æ –¥–Ω—è
            today_data = {
                "date": datetime.now().strftime("%Y-%m-%d"),
                "city": city,
                "current": {
                    "temp": current_temp or 0,
                },
                "forecast": result.get('forecast', {})
            }
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            message = f"üåÖ –î–æ–±—Ä–æ–µ —É—Ç—Ä–æ! –í–∞—à —É—Ç—Ä–µ–Ω–Ω–∏–π –¥–∞–π–¥–∂–µ—Å—Ç –¥–ª—è –≥–æ—Ä–æ–¥–∞ {city}:\n\n"
            message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            
            # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–≥–æ–¥—É
            message += "üå§Ô∏è –ü–û–ì–û–î–ê:\n\n"
            message += result['weather_info'] + "\n\n"
            
            # –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –¥–µ–Ω—å –µ—Å–ª–∏ –µ—Å—Ç—å
            if 'forecast' in result:
                fc = result['forecast']
                message += f"üìä –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –¥–µ–Ω—å:\n"
                message += f"üî∫ –ú–∞–∫—Å: {fc['temp_max']}¬∞C\n"
                message += f"üîª –ú–∏–Ω: {fc['temp_min']}¬∞C\n"
                message += f"üíß –û—Å–∞–¥–∫–∏: {fc['precipitation_probability']}%\n"
                message += f"‚òÄÔ∏è –í–æ—Å—Ö–æ–¥: {fc['sunrise'][11:16]}, –∑–∞–∫–∞—Ç: {fc['sunset'][11:16]}\n\n"
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –≤—á–µ—Ä–∞ –µ—Å–ª–∏ –µ—Å—Ç—å –∏—Å—Ç–æ—Ä–∏—è
            if user_id_str in history:
                yesterday_data = history[user_id_str]
                logger.info(f"Generating comparison for user {user_id}")
                
                comparison = await generate_comparison_summary(yesterday_data, today_data, city)
                message += f"üìà –ò–∑–º–µ–Ω–µ–Ω–∏—è:\n{comparison}\n\n"
            else:
                message += "üìä –ü–µ—Ä–≤–æ–µ —É—Ç—Ä–µ–Ω–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ –≤—á–µ—Ä–∞)\n\n"
            
            message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            
            # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ—Å—Ç–∏
            if news_result and 'items' in news_result:
                message += "üì∞ –ì–õ–ê–í–ù–´–ï –ù–û–í–û–°–¢–ò:\n\n"
                for idx, item in enumerate(news_result['items'][:3], 1):
                    message += f"{idx}. {item['title']}\n"
                    # –ö–æ—Ä–æ—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–ø–µ—Ä–≤—ã–µ 100 —Å–∏–º–≤–æ–ª–æ–≤)
                    desc = item['description'][:100]
                    if len(item['description']) > 100:
                        desc += '...'
                    message += f"   {desc}\n\n"
            else:
                message += "üì∞ –ù–æ–≤–æ—Å—Ç–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã\n\n"
            
            message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            message += "–•–æ—Ä–æ—à–µ–≥–æ –¥–Ω—è! ‚òÄÔ∏è"
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            await bot_instance.send_message(chat_id=user_id, text=message)
            logger.info(f"‚úì Sent morning broadcast to user {user_id}")
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é - —Å–µ–≥–æ–¥–Ω—è—à–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –≤—á–µ—Ä–∞—à–Ω–∏–º–∏
            history[user_id_str] = today_data
            
        except Exception as e:
            logger.error(f"Error sending morning broadcast to user {user_id_str}: {e}")
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—É—é –∏—Å—Ç–æ—Ä–∏—é
    save_weather_history(history)
    logger.info("üåÖ Morning weather + news broadcast completed")

# =============================================================================
# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
# =============================================================================

def serialize_message_content(content):
    """
    –°–µ—Ä–∏–∞–ª–∏–∑—É–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ JSON.
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Ç–∏–ø—ã –∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ Anthropic.
    """
    if isinstance(content, str):
        return content
    elif isinstance(content, list):
        result = []
        for item in content:
            if hasattr(item, 'model_dump'):
                result.append(item.model_dump())
            elif isinstance(item, dict):
                result.append(item)
            else:
                result.append(str(item))
        return result
    elif hasattr(content, 'model_dump'):
        return content.model_dump()
    elif isinstance(content, dict):
        return content
    else:
        return str(content)

def clean_json_response(text: str) -> str:
    """–û—á–∏—Å—Ç–∏—Ç—å JSON –æ—Ç–≤–µ—Ç –æ—Ç markdown –±–ª–æ–∫–æ–≤ –∫–æ–¥–∞"""
    text = text.strip()
    if text.startswith('```json'):
        text = text[7:]
    elif text.startswith('```'):
        text = text[3:]
    if text.endswith('```'):
        text = text[:-3]
    return text.strip()

async def compress_conversation(user_id: int) -> bool:
    """
    –°–∂–∞—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Ä–∞–∑–≥–æ–≤–æ—Ä–∞, —Å–æ–∑–¥–∞–≤ –∫—Ä–∞—Ç–∫–æ–µ —Å–∞–º–º–∞—Ä–∏ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
    –∏ –∑–∞–º–µ–Ω–∏–≤ –∏—Ö –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
    """
    try:
        messages = load_conversation(user_id)
        
        if len(messages) < COMPRESSION_THRESHOLD:
            return False
        
        # –ë–µ—Ä—ë–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ COMPRESSION_THRESHOLD —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —Å–∂–∞—Ç–∏—è
        messages_to_compress = messages[-COMPRESSION_THRESHOLD:]
        
        logger.info(f"Compressing {len(messages_to_compress)} messages for user {user_id}")
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è —Å–∂–∞—Ç–∏—è
        conversation_text = ""
        for msg in messages_to_compress:
            role = msg.get('role', 'unknown')
            content = msg.get('content', '')
            
            # –ï—Å–ª–∏ content —ç—Ç–æ JSON —Å—Ç—Ä–æ–∫–∞, –ø—ã—Ç–∞–µ–º—Å—è –µ—ë —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å
            if isinstance(content, str) and content.startswith('{'):
                try:
                    parsed = json.loads(content)
                    if 'user_message' in parsed and 'ai_message' in parsed:
                        conversation_text += f"User: {parsed['user_message']}\n"
                        conversation_text += f"Assistant: {parsed['ai_message']}\n\n"
                    else:
                        conversation_text += f"{role}: {content}\n\n"
                except:
                    conversation_text += f"{role}: {content}\n\n"
            else:
                conversation_text += f"{role}: {content}\n\n"
        
        # –ó–∞–ø—Ä–æ—Å –∫ Claude –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–∞–º–º–∞—Ä–∏
        response = anthropic_client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=500,
            system=COMPRESSION_SYSTEM_PROMPT,
            messages=[
                {
                    "role": "user",
                    "content": f"Create a summary of this conversation:\n\n{conversation_text}"
                }
            ]
        )
        
        summary_text = response.content[0].text
        summary_json = json.loads(clean_json_response(summary_text))
        summary = summary_json.get('summary', 'Summary of recent conversation')
        
        # –ó–∞–º–µ–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ COMPRESSION_THRESHOLD —Å–æ–æ–±—â–µ–Ω–∏–π –æ–¥–Ω–∏–º —Å–∂–∞—Ç—ã–º
        compressed_message = {
            "role": "user",
            "content": f"üì¶ –°–∂–∞—Ç–∞—è –∏—Å—Ç–æ—Ä–∏—è ({COMPRESSION_THRESHOLD} —Å–æ–æ–±—â–µ–Ω–∏–π): {summary}"
        }
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é: –æ—Å—Ç–∞–≤–ª—è–µ–º –≤—Å—ë –¥–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö COMPRESSION_THRESHOLD –∏ –¥–æ–±–∞–≤–ª—è–µ–º —Å–∂–∞—Ç–æ–µ
        new_messages = messages[:-COMPRESSION_THRESHOLD] + [compressed_message]
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—É—é –∏—Å—Ç–æ—Ä–∏—é
        if save_conversation(user_id, new_messages):
            logger.info(f"‚úì Successfully compressed and saved conversation for user {user_id}")
            logger.info(f"Summary: {summary}")
            return True
        else:
            logger.error(f"Failed to save compressed conversation for user {user_id}")
            return False
        
    except Exception as e:
        logger.error(f"Error compressing conversation for user {user_id}: {e}")
        return False

async def send_long_message(update: Update, text: str):
    """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–ª–∏–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, —Ä–∞–∑–±–∏–≤ –µ–≥–æ –Ω–∞ —á–∞—Å—Ç–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ"""
    max_length = 4000
    
    if len(text) <= max_length:
        await update.message.reply_text(text)
        return
    
    # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —á–∞—Å—Ç–∏
    parts = []
    while text:
        if len(text) <= max_length:
            parts.append(text)
            break
        
        # –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø–µ—Ä–µ–Ω–æ—Å —Å—Ç—Ä–æ–∫–∏ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö max_length
        split_pos = text.rfind('\n', 0, max_length)
        if split_pos == -1:
            split_pos = max_length
        
        parts.append(text[:split_pos])
        text = text[split_pos:].lstrip()
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–∞—Å—Ç–∏
    for i, part in enumerate(parts, 1):
        if len(parts) > 1:
            await update.message.reply_text(f"[–ß–∞—Å—Ç—å {i}/{len(parts)}]\n\n{part}")
        else:
            await update.message.reply_text(part)

# =============================================================================
# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
# =============================================================================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    await update.message.reply_text(
        "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π Claude AI, –ø–æ–≥–æ–¥–æ–π, –Ω–æ–≤–æ—Å—Ç—è–º–∏ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º Android —ç–º—É–ª—è—Ç–æ—Ä–æ–º.\n\n"
        "üí¨ –ü—Ä–æ—Å—Ç–æ –ø–∏—à–∏—Ç–µ –º–Ω–µ –≤–æ–ø—Ä–æ—Å—ã - —è –æ—Ç–≤–µ—á—É –∏—Å–ø–æ–ª—å–∑—É—è Claude AI\n\n"
        "üå§Ô∏è –ü–æ–≥–æ–¥–∞:\n"
        "‚Ä¢ /weather_subscribe –ì–æ—Ä–æ–¥ - –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —É—Ç—Ä–µ–Ω–Ω—é—é –ø–æ–≥–æ–¥—É\n"
        "‚Ä¢ /weather_unsubscribe - –æ—Ç–ø–∏—Å–∞—Ç—å—Å—è –æ—Ç –ø–æ–≥–æ–¥—ã\n"
        "‚Ä¢ /weather_list - –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É\n\n"
        "üì∞ –î–∞–π–¥–∂–µ—Å—Ç:\n"
        "‚Ä¢ /morning_digest - –ø–æ–ª—É—á–∏—Ç—å –ø–æ–≥–æ–¥—É + –Ω–æ–≤–æ—Å—Ç–∏ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å\n\n"
        "üì± –ú–æ–±–∏–ª—å–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞:\n"
        "‚Ä¢ /mobile_devices - –ø–æ–∫–∞–∑–∞—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞\n"
        "‚Ä¢ /start_emulator - –∑–∞–ø—É—Å—Ç–∏—Ç—å Android —ç–º—É–ª—è—Ç–æ—Ä\n\n"
        "üìä –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:\n"
        "‚Ä¢ /clear - –æ—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é\n"
        "‚Ä¢ /stats - –ø–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É\n"
        "‚Ä¢ /debug - –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"
    )

async def clear_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Ä–∞–∑–≥–æ–≤–æ—Ä–∞"""
    user_id = update.effective_user.id
    
    if delete_conversation(user_id):
        await update.message.reply_text("‚úÖ –ò—Å—Ç–æ—Ä–∏—è –æ—á–∏—â–µ–Ω–∞")
    else:
        await update.message.reply_text("‚úÖ –ò—Å—Ç–æ—Ä–∏—è —É–∂–µ –ø—É—Å—Ç–∞")

async def show_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏—Å—Ç–æ—Ä–∏–∏"""
    user_id = update.effective_user.id
    stats = get_conversation_stats(user_id)
    
    if not stats['exists']:
        await update.message.reply_text("üìä –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–æ–≤")
        return
    
    await update.message.reply_text(
        f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤–∞—à–µ–π –∏—Å—Ç–æ—Ä–∏–∏:\n\n"
        f"üí¨ –°–æ–æ–±—â–µ–Ω–∏–π: {stats['message_count']}\n"
        f"üì¶ –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: {stats['file_size_mb']} –ú–ë\n"
        f"üìÅ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: {MAX_FILE_SIZE // (1024*1024)} –ú–ë\n"
        f"üìù –ú–∞–∫—Å–∏–º—É–º —Å–æ–æ–±—â–µ–Ω–∏–π: {MAX_HISTORY_LENGTH}"
    )

async def debug_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏"""
    user_id = update.effective_user.id
    messages = load_conversation(user_id)
    
    if not messages:
        await update.message.reply_text("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞")
        return
    
    last_message = messages[-1]
    debug_text = f"üõ† –ü–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:\n\n```json\n{json.dumps(last_message, ensure_ascii=False, indent=2)}\n```"
    
    await update.message.reply_text(debug_text, parse_mode='Markdown')

async def weather_subscribe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —É—Ç—Ä–µ–Ω–Ω—é—é –ø–æ–≥–æ–¥—É"""
    user_id = update.effective_user.id
    
    logger.info(f"weather_subscribe called for user {user_id}")
    
    if not context.args:
        logger.info("No city provided")
        await update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ –≥–æ—Ä–æ–¥!\n\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /weather_subscribe –ú–æ—Å–∫–≤–∞")
        return
    
    city = ' '.join(context.args)
    logger.info(f"City: {city}")
    
    try:
        await update.message.reply_text(f"‚è≥ –ü–æ–ª—É—á–∞—é –ø–æ–≥–æ–¥—É –¥–ª—è –≥–æ—Ä–æ–¥–∞ {city}...")
        
        if not mcp_weather_client:
            logger.error("mcp_weather_client is None!")
            await update.message.reply_text("‚ùå MCP Weather —Å–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
            return
        
        result = await mcp_weather_client.call_tool("get_weather", {"city": city, "include_forecast": True})
        
        if not result:
            logger.error("MCP returned None")
            await update.message.reply_text(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–æ–≥–æ–¥—É –¥–ª—è –≥–æ—Ä–æ–¥–∞ {city}")
            return
        
        if 'weather_info' not in result:
            logger.error(f"No weather_info in result: {result}")
            await update.message.reply_text(f"‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ–≥–æ–¥–µ")
            return
        
        # –°–æ–∑–¥–∞—ë–º —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –≤—á–µ—Ä–∞—à–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ
        result['city'] = city
        yesterday_data = simulate_yesterday_weather(result)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
        history = load_weather_history()
        history[str(user_id)] = yesterday_data
        save_weather_history(history)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É
        subs = load_weather_subscriptions()
        subs[str(user_id)] = {
            "city": city,
            "time": "08:00",
            "timezone": "Europe/Moscow"
        }
        save_weather_subscriptions(subs)
        
        await update.message.reply_text(
            f"‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —É—Ç—Ä–µ–Ω–Ω—é—é –ø–æ–≥–æ–¥—É –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!\n\n"
            f"üåç –ì–æ—Ä–æ–¥: {city}\n"
            f"‚è∞ –í—Ä–µ–º—è: 08:00 (Europe/Moscow)\n\n"
            f"üìä –°–æ–∑–¥–∞–Ω–∞ —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏—Å—Ç–æ—Ä–∏—è –∑–∞ –≤—á–µ—Ä–∞ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è.\n"
            f"–ó–∞–≤—Ç—Ä–∞ —É—Ç—Ä–æ–º –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø—Ä–æ–≥–Ω–æ–∑–æ–º!"
        )
        
        logger.info(f"User {user_id} subscribed to weather for {city}")
        
    except Exception as e:
        logger.error(f"Exception in weather_subscribe: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏: {str(e)}")

async def weather_unsubscribe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û—Ç–ø–∏—Å–∞—Ç—å—Å—è –æ—Ç —É—Ç—Ä–µ–Ω–Ω–µ–π –ø–æ–≥–æ–¥—ã"""
    user_id = update.effective_user.id
    
    try:
        subs = load_weather_subscriptions()
        
        if str(user_id) not in subs:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –ø–æ–≥–æ–¥—É")
            return
        
        city = subs[str(user_id)]['city']
        del subs[str(user_id)]
        save_weather_subscriptions(subs)
        
        # –£–¥–∞–ª—è–µ–º –∏ –∏—Å—Ç–æ—Ä–∏—é
        history = load_weather_history()
        if str(user_id) in history:
            del history[str(user_id)]
            save_weather_history(history)
        
        await update.message.reply_text(
            f"‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –ø–æ–≥–æ–¥—É –¥–ª—è –≥–æ—Ä–æ–¥–∞ {city} –æ—Ç–º–µ–Ω–µ–Ω–∞"
        )
        
        logger.info(f"User {user_id} unsubscribed from weather")
        
    except Exception as e:
        logger.error(f"Error in weather_unsubscribe: {e}")
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

async def weather_list(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â—É—é –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ –ø–æ–≥–æ–¥—É"""
    user_id = update.effective_user.id
    
    try:
        subs = load_weather_subscriptions()
        
        if str(user_id) not in subs:
            await update.message.reply_text(
                "‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –ø–æ–≥–æ–¥—É\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /weather_subscribe –ú–æ—Å–∫–≤–∞"
            )
            return
        
        sub = subs[str(user_id)]
        
        await update.message.reply_text(
            f"‚úÖ –ê–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞:\n\n"
            f"üåç –ì–æ—Ä–æ–¥: {sub['city']}\n"
            f"‚è∞ –í—Ä–µ–º—è: {sub['time']}\n"
            f"üåê –ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {sub['timezone']}"
        )
        
    except Exception as e:
        logger.error(f"Error in weather_list: {e}")
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

async def morning_digest(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–ª—É—á–∏—Ç—å —É—Ç—Ä–µ–Ω–Ω–∏–π –¥–∞–π–¥–∂–µ—Å—Ç: –ø–æ–≥–æ–¥–∞ + –Ω–æ–≤–æ—Å—Ç–∏"""
    user_id = update.effective_user.id
    
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –ø–æ–≥–æ–¥—É
        subs = load_weather_subscriptions()
        
        if str(user_id) not in subs:
            await update.message.reply_text(
                "‚ùå –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –ø–æ–≥–æ–¥—É!\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /weather_subscribe –ì–æ—Ä–æ–¥"
            )
            return
        
        city = subs[str(user_id)]['city']
        
        await update.message.reply_text(f"‚è≥ –ü–æ–ª—É—á–∞—é —É—Ç—Ä–µ–Ω–Ω–∏–π –¥–∞–π–¥–∂–µ—Å—Ç –¥–ª—è {city}...")
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ–≥–æ–¥—É
        weather_result = None
        if mcp_weather_client:
            weather_result = await mcp_weather_client.call_tool(
                "get_weather",
                {"city": city, "include_forecast": True}
            )
        
        # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤–æ—Å—Ç–∏
        news_result = None
        if mcp_news_client:
            news_result = await mcp_news_client.call_tool(
                "get_news",
                {"category": "–æ–±—â–∏–µ", "limit": 3}
            )
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∞–π–¥–∂–µ—Å—Ç
        digest = f"üåÖ –£—Ç—Ä–µ–Ω–Ω–∏–π –¥–∞–π–¥–∂–µ—Å—Ç –¥–ª—è {city}\n\n"
        digest += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–≥–æ–¥—É
        if weather_result and 'weather_info' in weather_result:
            digest += "üå§Ô∏è –ü–û–ì–û–î–ê:\n\n"
            digest += weather_result['weather_info'] + "\n\n"
            
            if 'forecast' in weather_result:
                fc = weather_result['forecast']
                digest += f"üìä –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –¥–µ–Ω—å:\n"
                digest += f"üî∫ –ú–∞–∫—Å: {fc['temp_max']}¬∞C\n"
                digest += f"üîª –ú–∏–Ω: {fc['temp_min']}¬∞C\n"
                digest += f"üíß –û—Å–∞–¥–∫–∏: {fc['precipitation_probability']}%\n\n"
        else:
            digest += "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–æ–≥–æ–¥—É\n\n"
        
        digest += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        
        # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ—Å—Ç–∏
        if news_result and 'news_text' in news_result:
            digest += "üì∞ –ù–û–í–û–°–¢–ò:\n\n"
            digest += news_result['news_text'] + "\n\n"
        else:
            digest += "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –Ω–æ–≤–æ—Å—Ç–∏\n\n"
        
        digest += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        await send_long_message(update, digest)
        logger.info(f"Sent morning digest to user {user_id}")
        
    except Exception as e:
        logger.error(f"Error in morning_digest: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–π–¥–∂–µ—Å—Ç–∞: {str(e)}")

async def mobile_devices(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–∫–∞–∑–∞—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–±–∏–ª—å–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞"""
    user_id = update.effective_user.id
    
    try:
        await update.message.reply_text("‚è≥ –ü–æ–ª—É—á–∞—é —Å–ø–∏—Å–æ–∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤...")
        
        if not mcp_mobile_client:
            await update.message.reply_text("‚ùå MCP Mobile —Å–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
            return
        
        # –í—ã–∑—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤
        result = await mcp_mobile_client.call_tool(
            "mobile_list_available_devices",
            {"noParams": {}}
        )
        
        if not result or 'devices' not in result:
            await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤")
            return
        
        devices = result['devices']
        
        if not devices:
            await update.message.reply_text("üì± –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤")
            return
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∫—Ä–∞—Å–∏–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        message = "üì± –î–æ—Å—Ç—É–ø–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞:\n\n"
        
        for idx, device in enumerate(devices, 1):
            message += f"{idx}. **{device['name']}**\n"
            message += f"   ID: `{device['id']}`\n"
            message += f"   –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞: {device['platform']}\n"
            message += f"   –¢–∏–ø: {device['type']}\n"
            message += f"   –í–µ—Ä—Å–∏—è: {device['version']}\n"
            message += f"   –°—Ç–∞—Ç—É—Å: {'üü¢ ' if device['state'] == 'online' else 'üî¥ '}{device['state']}\n\n"
        
        await update.message.reply_text(message, parse_mode='Markdown')
        logger.info(f"Sent device list to user {user_id}")
        
    except Exception as e:
        logger.error(f"Error in mobile_devices: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

async def start_emulator(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ó–∞–ø—É—Å—Ç–∏—Ç—å Android —ç–º—É–ª—è—Ç–æ—Ä"""
    user_id = update.effective_user.id
    
    try:
        await update.message.reply_text("‚è≥ –ü—Ä–æ–≤–µ—Ä—è—é —Å—Ç–∞—Ç—É—Å —ç–º—É–ª—è—Ç–æ—Ä–∞...")
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º —Å–∫—Ä–∏–ø—Ç –∑–∞–ø—É—Å–∫–∞ —ç–º—É–ª—è—Ç–æ—Ä–∞ —á–µ—Ä–µ–∑ SSH
        process = await asyncio.create_subprocess_exec(
            'ssh',
            '-i', MCP_MOBILE_SSH_KEY,
            '-p', str(MCP_MOBILE_SSH_PORT),
            '-o', 'StrictHostKeyChecking=no',
            '-o', 'UserKnownHostsFile=/dev/null',
            f'{MCP_MOBILE_SSH_USER}@{MCP_MOBILE_SSH_HOST}',
            MCP_MOBILE_START_EMULATOR_SCRIPT,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await process.communicate()
        
        if process.returncode != 0:
            error_msg = stderr.decode().strip()
            logger.error(f"Emulator start script failed: {error_msg}")
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞: {error_msg}")
            return
        
        # –ü–∞—Ä—Å–∏–º JSON –æ—Ç–≤–µ—Ç
        result = json.loads(stdout.decode().strip())
        
        status = result.get('status', 'unknown')
        message = result.get('message', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å—Ç–∞—Ç—É—Å')
        device_id = result.get('device_id', '')
        
        if status == 'already_running':
            await update.message.reply_text(
                f"‚úÖ {message}\n\n"
                f"üì± ID —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: `{device_id}`"
            )
        elif status == 'started':
            await update.message.reply_text(
                f"üöÄ {message}\n\n"
                f"üì± ID —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: `{device_id}`\n\n"
                f"–≠–º—É–ª—è—Ç–æ—Ä –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!"
            )
        else:
            await update.message.reply_text(f"‚ùå {message}")
        
        logger.info(f"Emulator command executed for user {user_id}: {status}")
        
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse emulator script output: {e}")
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—Ç–≤–µ—Ç–∞ –æ—Ç —ç–º—É–ª—è—Ç–æ—Ä–∞")
    except Exception as e:
        logger.error(f"Error in start_emulator: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

# =============================================================================
# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π
# =============================================================================

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"""
    user_id = update.effective_user.id
    user_message = update.message.text
    
    logger.info(f"Received message from {user_id}: {user_message[:50]}...")
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –∏–∑ —Ñ–∞–π–ª–∞
    messages = load_conversation(user_id)
    
    try:
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤ –æ–±—ã—á–Ω–æ–º —Ä–µ–∂–∏–º–µ (–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —Ä–µ–∂–∏–º —Ç–µ–ø–µ—Ä—å)
        await handle_normal_mode(update, user_id, user_message, messages)
            
    except Exception as e:
        logger.error(f"Error handling message: {e}")
        await update.message.reply_text(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {str(e)}")

async def handle_normal_mode(update: Update, user_id: int, user_message: str, messages: list):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±—ã—á–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π MCP Weather, News –∏ Mobile"""
    
    # –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    messages.append({
        "role": "user",
        "content": user_message
    })
    
    # –û–ø–∏—Å–∞–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è Claude
    tools = [
        {
            "name": "get_weather",
            "description": "Get current weather information for a city. Use this when the user asks about weather, temperature, or atmospheric conditions in a specific location.",
            "input_schema": {
                "type": "object",
                "properties": {
                    "city": {
                        "type": "string",
                        "description": "The name of the city to get weather for (in any language)"
                    }
                },
                "required": ["city"]
            }
        },
        {
            "name": "get_news",
            "description": "Get latest news from Russian RSS feeds. Use this when the user asks about news, current events, or headlines. Categories: –æ–±—â–∏–µ (general), —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ (tech), –±–∏–∑–Ω–µ—Å (business)",
            "input_schema": {
                "type": "object",
                "properties": {
                    "category": {
                        "type": "string",
                        "description": "News category: –æ–±—â–∏–µ, —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏, or –±–∏–∑–Ω–µ—Å",
                        "enum": ["–æ–±—â–∏–µ", "—Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏", "–±–∏–∑–Ω–µ—Å"]
                    },
                    "limit": {
                        "type": "number",
                        "description": "Number of news items to return (1-10)",
                        "minimum": 1,
                        "maximum": 10
                    }
                },
                "required": []
            }
        },
        {
            "name": "mobile_list_available_devices",
            "description": "List all available mobile devices including Android emulators and iOS simulators. Use this when the user asks about available devices, wants to see what devices are connected, or needs to select a device.",
            "input_schema": {
                "type": "object",
                "properties": {
                    "noParams": {
                        "type": "object",
                        "properties": {}
                    }
                },
                "required": ["noParams"]
            }
        },
        {
            "name": "mobile_start_emulator",
            "description": "Start the Android emulator if it's not running, or check if it's already running. Use this when the user wants to start/launch the emulator or when they ask if the emulator is ready.",
            "input_schema": {
                "type": "object",
                "properties": {
                    "noParams": {
                        "type": "object",
                        "properties": {}
                    }
                },
                "required": ["noParams"]
            }
        },
        {
            "name": "search_knowledge",
            "description": "Search knowledge base using RAG",
            "input_schema": {
                "type": "object",
                "properties": {
                    "query": {"type": "string", "description": "Search query"},
                    "top_k": {"type": "number", "default": 3}
                },
                "required": ["query"]
            }
        }
    ]
    
    # –ü–µ—Ä–≤—ã–π –∑–∞–ø—Ä–æ—Å –∫ Claude
    response = anthropic_client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=2000,
        tools=tools,
        messages=messages
    )
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –ª–∏ Claude –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç
    tool_use_block = None
    text_response = ""
    
    for block in response.content:
        if block.type == "tool_use":
            tool_use_block = block
        elif block.type == "text":
            text_response += block.text
    
    if tool_use_block:
        # Claude —Ö–æ—á–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–¥–∏–Ω –∏–∑ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
        logger.info(f"Claude wants to use tool: {tool_use_block.name} with args: {tool_use_block.input}")
        
        # –í—ã–±–∏—Ä–∞–µ–º –Ω—É–∂–Ω—ã–π MCP –∫–ª–∏–µ–Ω—Ç
        tool_result = None
        if tool_use_block.name == "get_weather":
            tool_result = await mcp_weather_client.call_tool(
                tool_use_block.name,
                tool_use_block.input
            )
        elif tool_use_block.name == "get_news":
            tool_result = await mcp_news_client.call_tool(
                tool_use_block.name,
                tool_use_block.input
            )
        elif tool_use_block.name == "mobile_list_available_devices":
            tool_result = await mcp_mobile_client.call_tool(
                tool_use_block.name,
                tool_use_block.input
            )
        elif tool_use_block.name == "mobile_start_emulator":
            # –ó–∞–ø—É—Å–∫–∞–µ–º —ç–º—É–ª—è—Ç–æ—Ä —á–µ—Ä–µ–∑ SSH —Å–∫—Ä–∏–ø—Ç
            try:
                process = await asyncio.create_subprocess_exec(
                    'ssh',
                    '-i', MCP_MOBILE_SSH_KEY,
                    '-p', str(MCP_MOBILE_SSH_PORT),
                    '-o', 'StrictHostKeyChecking=no',
                    '-o', 'UserKnownHostsFile=/dev/null',
                    f'{MCP_MOBILE_SSH_USER}@{MCP_MOBILE_SSH_HOST}',
                    MCP_MOBILE_START_EMULATOR_SCRIPT,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if process.returncode == 0:
                    tool_result = json.loads(stdout.decode().strip())
                else:
                    tool_result = {
                        "status": "error",
                        "message": f"–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–∫—Ä–∏–ø—Ç–∞: {stderr.decode().strip()}"
                    }
            except Exception as e:
                logger.error(f"Error calling start emulator script: {e}")
                tool_result = {
                    "status": "error",
                    "message": f"–û—à–∏–±–∫–∞: {str(e)}"
                }
        
        
        elif tool_use_block.name == "search_knowledge":
            # RAG –ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ Ollama MCP
            if not mcp_ollama_client:
                tool_result = {
                    "error": "Ollama MCP server not available",
                    "results": []
                }
            else:
                try:
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º vector_store_search –¥–ª—è –ø–æ–∏—Å–∫–∞
                    search_result = await mcp_ollama_client.call_tool(
                        "vector_store_search",
                        {
                            "store_name": "bot_knowledge",
                            "query": tool_use_block.input.get("query"),
                            "top_k": tool_use_block.input.get("top_k", 3)
                        }
                    )
                    
                    if search_result and "results" in search_result:
                        tool_result = {
                            "results": search_result["results"],
                            "total_chunks": search_result.get("total_chunks", 0)
                        }
                    else:
                        tool_result = {
                            "error": "No results found",
                            "results": []
                        }
                except Exception as e:
                    logger.error(f"Error in search_knowledge: {e}")
                    tool_result = {
                        "error": str(e),
                        "results": []
                    }
        
        if tool_result:
            # –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç Claude —Å tool_use –≤ –∏—Å—Ç–æ—Ä–∏—é
            messages.append({
                "role": "assistant",
                "content": serialize_message_content(response.content)
            })
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
            messages.append({
                "role": "user",
                "content": [
                    {
                        "type": "tool_result",
                        "tool_use_id": tool_use_block.id,
                        "content": json.dumps(tool_result, ensure_ascii=False)
                    }
                ]
            })
            
            # –í—Ç–æ—Ä–æ–π –∑–∞–ø—Ä–æ—Å –∫ Claude —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
            response = anthropic_client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=2000,
                tools=tools,
                messages=messages
            )
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç
            final_response = ""
            for block in response.content:
                if block.type == "text":
                    final_response += block.text
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
            messages.append({
                "role": "assistant",
                "content": json.dumps({
                    "user_message": user_message,
                    "ai_message": final_response
                }, ensure_ascii=False)
            })
            
            ai_response = final_response
        else:
            # –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
            ai_response = "–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ."
            messages.append({
                "role": "assistant",
                "content": json.dumps({
                    "user_message": user_message,
                    "ai_message": ai_response
                }, ensure_ascii=False)
            })
    else:
        # –û–±—ã—á–Ω—ã–π –æ—Ç–≤–µ—Ç –±–µ–∑ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
        ai_response = text_response
        
        messages.append({
            "role": "assistant",
            "content": json.dumps({
                "user_message": user_message,
                "ai_message": ai_response
            }, ensure_ascii=False)
        })
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ç–æ—Ä–∏—é
    save_conversation(user_id, messages)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    stats_text = f"\n\nüìä –¢–æ–∫–µ–Ω—ã: –≤–æ–ø—Ä–æ—Å {response.usage.input_tokens} | –æ—Ç–≤–µ—Ç {response.usage.output_tokens}"
    await send_long_message(update, ai_response + stats_text)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å —Å–∂–∞—Ç–∏—è
    if len(messages) >= COMPRESSION_THRESHOLD:
        compressed = await compress_conversation(user_id)
        if compressed:
            await update.message.reply_text("üì¶ –ò—Å—Ç–æ—Ä–∏—è —Å–∂–∞—Ç–∞ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ —Ç–æ–∫–µ–Ω–æ–≤")

# =============================================================================
# –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
# =============================================================================

def main():
    """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
    global mcp_weather_client, mcp_news_client, mcp_mobile_client, scheduler, bot_instance
    
    # –°–æ–∑–¥–∞—ë–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –∏—Å—Ç–æ—Ä–∏–π
    ensure_conversations_dir()
    
    # –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    
    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("clear", clear_history))
    application.add_handler(CommandHandler("stats", show_stats))
    application.add_handler(CommandHandler("debug", debug_history))
    application.add_handler(CommandHandler("weather_subscribe", weather_subscribe))
    application.add_handler(CommandHandler("weather_unsubscribe", weather_unsubscribe))
    application.add_handler(CommandHandler("weather_list", weather_list))
    application.add_handler(CommandHandler("morning_digest", morning_digest))
    application.add_handler(CommandHandler("mobile_devices", mobile_devices))
    application.add_handler(CommandHandler("start_emulator", start_emulator))

    # –í—Ä–µ–º–µ–Ω–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è —Ç–µ—Å—Ç–∞ —É—Ç—Ä–µ–Ω–Ω–µ–π —Ä–∞—Å—Å—ã–ª–∫–∏
    async def test_morning_weather(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–¢–ï–°–¢: –ó–∞–ø—É—Å—Ç–∏—Ç—å —É—Ç—Ä–µ–Ω–Ω—é—é —Ä–∞—Å—Å—ã–ª–∫—É –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å"""
        await update.message.reply_text("‚è≥ –ó–∞–ø—É—Å–∫–∞—é —É—Ç—Ä–µ–Ω–Ω—é—é —Ä–∞—Å—Å—ã–ª–∫—É...")
        await send_morning_weather()
        await update.message.reply_text("‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
    
    application.add_handler(CommandHandler("test_morning", test_morning_weather))
    
    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MCP –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    async def post_init(app):
        global mcp_weather_client, mcp_news_client, mcp_mobile_client, mcp_ollama_client, scheduler, bot_instance
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ scheduled –∑–∞–¥–∞—á–∞—Ö
        bot_instance = app.bot
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º MCP Weather Client
        logger.info("Starting MCP Weather Client...")
        mcp_weather_client = MCPWeatherClient(MCP_WEATHER_SERVER_PATH)
        if await mcp_weather_client.start():
            logger.info("‚úì MCP Weather Client initialized")
        else:
            logger.error("‚úó Failed to start MCP Weather Client")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º MCP News Client
        logger.info("Starting MCP News Client...")
        mcp_news_client = MCPNewsClient(MCP_NEWS_SERVER_PATH)
        if await mcp_news_client.start():
            logger.info("‚úì MCP News Client initialized")
        else:
            logger.error("‚úó Failed to start MCP News Client")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º MCP Mobile Client
        logger.info("Starting MCP Mobile Client...")
        mcp_mobile_client = MCPMobileClient(
            ssh_host=MCP_MOBILE_SSH_HOST,
            ssh_port=MCP_MOBILE_SSH_PORT,
            ssh_user=MCP_MOBILE_SSH_USER,
            ssh_key=MCP_MOBILE_SSH_KEY,
            server_path=MCP_MOBILE_SERVER_PATH
        )
        if await mcp_mobile_client.start():
            logger.info("‚úì MCP Mobile Client initialized")
        else:
            logger.error("‚úó Failed to start MCP Mobile Client")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
        scheduler = AsyncIOScheduler()
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º MCP Ollama Client (RAG)
        logger.info("Starting MCP Ollama Client...")
        mcp_ollama_client = MCPOllamaClient(
            ssh_host=MCP_OLLAMA_SSH_HOST,
            ssh_port=MCP_OLLAMA_SSH_PORT,
            ssh_user=MCP_OLLAMA_SSH_USER,
            ssh_key=MCP_OLLAMA_SSH_KEY,
            node_path=MCP_OLLAMA_NODE_PATH,
            server_path=MCP_OLLAMA_SERVER_PATH
        )
        if await mcp_ollama_client.start():
            logger.info("‚úì MCP Ollama Client initialized")
        else:
            logger.error("‚úó Failed to start MCP Ollama Client")
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á—É —É—Ç—Ä–µ–Ω–Ω–µ–π —Ä–∞—Å—Å—ã–ª–∫–∏ (–∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 8:00)
        scheduler.add_job(
            send_morning_weather,
            CronTrigger(hour=8, minute=0, timezone='Europe/Moscow'),
            id='morning_weather',
            name='Morning Weather Broadcast',
            replace_existing=True
        )
        
        scheduler.start()
        logger.info("‚úì Weather scheduler started (morning broadcast at 08:00 Moscow time)")
    
    # –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
    async def post_shutdown(app):
        if mcp_weather_client:
            await mcp_weather_client.stop()
        if mcp_news_client:
            await mcp_news_client.stop()
        if mcp_mobile_client:
            await mcp_mobile_client.stop()
        if mcp_ollama_client:
            await mcp_ollama_client.stop()
        if scheduler:
            scheduler.shutdown()
    
    application.post_init = post_init
    application.post_shutdown = post_shutdown
    
    logger.info("Bot is running...")
    
    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
    application.run_polling()

if __name__ == '__main__':
    main()
